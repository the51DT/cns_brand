<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title><%= data.title %></title>
  <meta name="description" content="<%= data.description %>">
  <link rel="stylesheet" href="/src/assets/css/index.css" />
  <link rel="shortcut icon" href="/src/assets/image/favicon.ico">
</head>
<body class="">
    <div class="wrap has-hero the-future-case">
        <%- include('src/_inc/header.html') %>
        <!-- //헤더 영역 -->
        <div class="sub-content__wrap">
            <div class="full-type-content__wrap">
                <div class="future-inner__wrap">
                    <div class="future-text">
                        <div class="main-title font-head-xl font-semibold">Generative AI</div>
                        <div class="sub-title font-head-md">in your work </div>
                        <div class="description-text font-body-md">
                            생성형 AI. 이제 관망의 시기는 지났습니다.<br>인터넷이 없는 업무 환경을 이제 생각할 수가 없듯이, 생성형 AI가 적용되지 않은 업무 시스템을 생각하기는 이제 어려운 세상이 되었습니다.
                        </div>
                        <a href="#" class="btn-glide">
                            <span class="btn-glide__inner">
                                <span class="btn-glide__text">생성형 AI 상세보기</span>
                            </span>
                            <i class="btn-glide__icon"></i>
                        </a>
                    </div>
                    <!-- //title -->
                    <div class="future-content">
                        <%
                            const itemListData = [
                                {
                                    imageUrl: '/src/assets/image/sub/future_img_ai.png',
                                    content : [
                                        {
                                            title : 'AI 트렌드 ',
                                            text : '최근 기업에서는 생성형 AI 기술을 활용해 생산성과 혁신을 극대화하고 있다. 초거대 언어 모델(LLM) 기반 기술은 고객 서비스에서 챗봇 및 자동화된 응답 시스템으로 활용되며, 맞춤형 마케팅 콘텐츠 생성에도 사용된다. 또한, 이미지 및 비디오 생성 AI는 디자인 및 광고 제작을 혁신하고, 코드 생성 AI는 소프트웨어 개발의 효율성을 높인다. 이 외에도 데이터 분석 자동화와 협업 도구 통합으로 업무 전반의 디지털 전환을 가속화하고 있다. 기업들은 이러한 기술을 통해 비용 절감과 고객 경험 개선을 동시에 이루고자 한다.'
                                        },
                                    ]
                                },
                                {
<!--                                    imageUrl: '/src/assets/image/sub/future_img_ai.png',-->
                                    content : [
                                        {
                                            title : '기업의 생산형 AI 도입의 고민',
                                            text : '최근 기업에서는 생성형 AI 기술을 활용해 생산성과 혁신을 극대화하고 있다. 초거대 언어 모델(LLM) 기반 기술은 고객 서비스에서 챗봇 및 자동화된 응답 시스템으로 활용되며, 맞춤형 마케팅 콘텐츠 생성에도 사용된다. 또한, 이미지 및 비디오 생성 AI는 디자인 및 광고 제작을 혁신하고, 코드 생성 AI는 소프트웨어 개발의 효율성을 높인다. 이 외에도 데이터 분석 자동화와 협업 도구 통합으로 업무 전반의 디지털 전환을 가속화하고 있다. 기업들은 이러한 기술을 통해 비용 절감과 고객 경험 개선을 동시에 이루고자 한다.'
                                        },
                                    ]
                                },
                                {
                                    imageUrl: '/src/assets/image/sub/future_img_ai.png',
                                    content : [
                                        {
                                            title : '기업의 생산형 AI 도입의 고민',
                                            text : '최근 기업에서는 생성형 AI 기술을 활용해 생산성과 혁신을 극대화하고 있다. 초거대 언어 모델(LLM) 기반 기술은 고객 서비스에서 챗봇 및 자동화된 응답 시스템으로 활용되며, 맞춤형 마케팅 콘텐츠 생성에도 사용된다. 또한, 이미지 및 비디오 생성 AI는 디자인 및 광고 제작을 혁신하고, 코드 생성 AI는 소프트웨어 개발의 효율성을 높인다. 이 외에도 데이터 분석 자동화와 협업 도구 통합으로 업무 전반의 디지털 전환을 가속화하고 있다. 기업들은 이러한 기술을 통해 비용 절감과 고객 경험 개선을 동시에 이루고자 한다.'
                                        },
                                    ]
                                },
                            ]
                        %>
                        <%- include('src/component/cmp_item_list.html', Object.assign({}, locals, { 
                            jsonData: itemListData,
                            itemCount: 5, 
                        })) %>  
                    </div>
                    <!-- //content -->
                </div>
            </div>
        </div>
        <%- include('src/_inc/footer.html', Object.assign({}, locals, {
            type : 'dark',
        }))%>
    </div>
</body>
<script>
    //버튼 스타일 스크립트
    const glideText = (() => {
        const text = document.querySelector('.btn-glide');
        if (!text) return;

        const textInner = text.querySelector('.btn-glide__inner');
        const textInnerWidth = textInner.offsetWidth;

        const init = () => {
            textInner.style.width = `0px`;
        };

        const animate = (isVisible) => {
            textInner.style.width = `${isVisible? textInnerWidth : 0}px`;
            text.classList.toggle('btn-glide--active', isVisible);
        };

        init(); // 최초 초기화

        return { animate };
    })();

    /*header 높이에 따른 컨텐츠 요소 덜걱거림 보정*/
    //1. 윈도우 로드 완료시, header 의 높이 측정, header에 fixed 스타일 부여
    //2. header 의 높이 만큼 .the-future-case 에 padding-top: header.height 반영
    //3. 스크롤 시, header의 높이만큼 스크롤이 지났다면 fixed 스타일 제거

    /*
        조건	동작
        스크롤 < 헤더 높이	헤더 원래 위치 (translateY(0))
        스크롤 > 헤더 높이 + 아래로 스크롤	헤더 숨김 (translateY(-6.25rem))
        스크롤 > 헤더 높이 + 위로 스크롤	헤더 보여짐 (translateY(0))
    */

    /*특정 높이(ex. header 의 높이만큼 지났을 때, btn btn-medium btn-primary 에 active 클래스 on)*/

    // 헤더 높이 측정 함수
    const getElementHeight = (element) => {
        return element ? element.offsetHeight : 100 // 기본값 100px
    }

    function setHeaderStyle() {
        const header = document.querySelector('.header')
        const primaryBtn = document.querySelector('.btn-glide')
        const futureCaseContainer = document.querySelector('.the-future-case')

        const headerHeight = getElementHeight(header)
        let isHeaderHidden = false
        let lastScrollY = window.scrollY
        let isAnimation = false

        // 스타일 설정 함수
        const setStyles = () => {
            // header 스타일 적용 객체
            const headerStyles = {
                position: 'fixed',
                top: '0',
                left: '0',
                transform: 'translateY(0)'
            }

            // 헤더와 컨테이너에 스타일 적용 (초기값)
            if (header && futureCaseContainer) {
                // 헤더에 스타일 적용
                // header.classList.add('is-fixed')
                Object.assign(header.style, headerStyles)

                // 컨테이너에 패딩 적용
                futureCaseContainer.style.paddingTop = `${headerHeight}px`
            }
        }

        // 스크롤에 따른 UI 업데이트 함수
        const updateUI = () => {
            const scrollPosition = window.scrollY
            const isScrollingDown = scrollPosition > lastScrollY
            const isBeyondHeader = scrollPosition >= headerHeight

            if (isBeyondHeader) {
                if (isScrollingDown && !isHeaderHidden) {
                    header.style.transform = 'translateY(-6.25rem)'
                    isHeaderHidden = true
                } else if (!isScrollingDown && isHeaderHidden) {
                    header.style.transform = 'translateY(0)'
                    isHeaderHidden = false
                }
            } else {
                if (isHeaderHidden) {
                    header.style.transform = 'translateY(0)'
                    isHeaderHidden = false
                }
            }
            lastScrollY = scrollPosition

            // 버튼 활성화/비활성화(필요시 사용)
            if (scrollPosition >= headerHeight && !isAnimation) {
                glideText.animate(true);
                isAnimation = true;
            } else if (scrollPosition < headerHeight && isAnimation) {
                // glideText.animate(false);
                // isAnimation = false;
            }
        };

        // 초기화 함수
        const init = () => {
            setStyles() // 초기 스타일 설정
            updateUI() // 초기 UI 상태 업데이트

            // 스크롤 이벤트 리스너 등록
            window.addEventListener('scroll', updateUI)
            // 리사이즈 이벤트 리스너 등록 (화면 크기 변경 시 재계산)
            window.addEventListener('resize', () => {
                // 스타일 재설정 및 UI 업데이트
                setStyles()
                updateUI()
            })
        }
        init()
    }



    /*실행*/
    window.addEventListener('load', () => {
        setHeaderStyle()
    })
</script>