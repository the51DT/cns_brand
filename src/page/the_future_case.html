<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title><%= data.title %></title>
  <meta name="description" content="<%= data.description %>">
  <link rel="stylesheet" href="/src/assets/css/index.css" />
  <link rel="shortcut icon" href="/src/assets/image/favicon.ico">
</head>
<body class="">
    <div class="wrap has-hero the-future-case">
        <%- include('src/_inc/header.html') %>
        <!-- //헤더 영역 -->
        <div class="sub-content__wrap">
            <div class="full-type-content__wrap">
                <div class="future-inner__wrap">
                    <div class="future-text">
                        <div class="main-title font-head-xl font-semibold">Generative AI</div>
                        <div class="sub-title font-head-md">in your work </div>
                        <div class="description-text font-body-md">
                            생성형 AI. 이제 관망의 시기는 지났습니다.<br>인터넷이 없는 업무 환경을 이제 생각할 수가 없듯이, 생성형 AI가 적용되지 않은 업무 시스템을 생각하기는 이제 어려운 세상이 되었습니다.
                        </div>
                        <a href="#" class="btn-glide">
                            <span class="btn-glide__inner">
                                <span class="btn-glide__text">생성형 AI 상세보기</span>
                            </span>
                            <i class="btn-glide__icon"></i>
                        </a>
                    </div>
                    <!-- //title -->
                    <div class="future-content">
                        <%
                            const itemListData = [
                                {
                                    imageUrl: '/src/assets/image/sub/future_img_ai.png',
                                    content : [
                                        {
                                            title : 'AI 트렌드 ',
                                            text : '최근 기업에서는 생성형 AI 기술을 활용해 생산성과 혁신을 극대화하고 있다. 초거대 언어 모델(LLM) 기반 기술은 고객 서비스에서 챗봇 및 자동화된 응답 시스템으로 활용되며, 맞춤형 마케팅 콘텐츠 생성에도 사용된다. 또한, 이미지 및 비디오 생성 AI는 디자인 및 광고 제작을 혁신하고, 코드 생성 AI는 소프트웨어 개발의 효율성을 높인다. 이 외에도 데이터 분석 자동화와 협업 도구 통합으로 업무 전반의 디지털 전환을 가속화하고 있다. 기업들은 이러한 기술을 통해 비용 절감과 고객 경험 개선을 동시에 이루고자 한다.'
                                        },
                                    ]
                                },
                                {
<!--                                    imageUrl: '/src/assets/image/sub/future_img_ai.png',-->
                                    content : [
                                        {
                                            title : '기업의 생산형 AI 도입의 고민',
                                            text : '최근 기업에서는 생성형 AI 기술을 활용해 생산성과 혁신을 극대화하고 있다. 초거대 언어 모델(LLM) 기반 기술은 고객 서비스에서 챗봇 및 자동화된 응답 시스템으로 활용되며, 맞춤형 마케팅 콘텐츠 생성에도 사용된다. 또한, 이미지 및 비디오 생성 AI는 디자인 및 광고 제작을 혁신하고, 코드 생성 AI는 소프트웨어 개발의 효율성을 높인다. 이 외에도 데이터 분석 자동화와 협업 도구 통합으로 업무 전반의 디지털 전환을 가속화하고 있다. 기업들은 이러한 기술을 통해 비용 절감과 고객 경험 개선을 동시에 이루고자 한다.'
                                        },
                                    ]
                                },
                                {
                                    imageUrl: '/src/assets/image/sub/future_img_ai.png',
                                    content : [
                                        {
                                            title : '기업의 생산형 AI 도입의 고민',
                                            text : '최근 기업에서는 생성형 AI 기술을 활용해 생산성과 혁신을 극대화하고 있다. 초거대 언어 모델(LLM) 기반 기술은 고객 서비스에서 챗봇 및 자동화된 응답 시스템으로 활용되며, 맞춤형 마케팅 콘텐츠 생성에도 사용된다. 또한, 이미지 및 비디오 생성 AI는 디자인 및 광고 제작을 혁신하고, 코드 생성 AI는 소프트웨어 개발의 효율성을 높인다. 이 외에도 데이터 분석 자동화와 협업 도구 통합으로 업무 전반의 디지털 전환을 가속화하고 있다. 기업들은 이러한 기술을 통해 비용 절감과 고객 경험 개선을 동시에 이루고자 한다.'
                                        },
                                    ]
                                },
                            ]
                        %>
                        <%- include('src/component/cmp_item_list.html', Object.assign({}, locals, { 
                            jsonData: itemListData,
                            itemCount: 5, 
                        })) %>  
                    </div>
                    <!-- //content -->
                </div>
            </div>
        </div>
        <%- include('src/_inc/footer.html', Object.assign({}, locals, {
            type : 'dark',
        }))%>
    </div>
</body>
<script>
    //버튼 스타일 스크립트
    const glideText = (() => {
        const text = document.querySelector('.btn-glide')
        if (!text) return

        const textInner = text.querySelector('.btn-glide__inner')
        const textInnerWidth = textInner.offsetWidth

        const init = () => {
            textInner.style.width = `0px`

            setTimeout(() => {
                animate(true)
            }, 500)
        }

        const animate = (isVisible) => {
            textInner.style.width = `${isVisible? textInnerWidth : 0}px`
            text.classList.toggle('btn-glide--active', isVisible)
        }

        init() // 실행
    })

    //모바일화면에서의 패럴랙스 모션
    function parallaxEffect() {
        const futureContent = document.querySelector('.future-content')
        const futureText = document.querySelector('.future-text')

        if (!futureContent || !futureText) return

        function handleScroll() {
            // 모바일 화면 여부 확인 ($tabletMini 기준)
            const isMobile = window.matchMedia('only screen and (max-width: 1023px)').matches

            if (isMobile) {
                const rect = futureContent.getBoundingClientRect()
                const windowHeight = window.innerHeight

                const thresholdTop = windowHeight * 0.3
                const thresholdBottom = windowHeight * 0.8

                if (rect.top <= thresholdBottom && rect.top >= thresholdTop) {
                    const ratio = (rect.top - thresholdTop) / (thresholdBottom - thresholdTop)

                    futureText.style.opacity = ratio.toFixed(2)

                    const translateY = 5 * (1 - ratio)
                    futureText.style.transform = `translateY(${translateY}%)`

                } else if (rect.top > thresholdBottom) {
                    // 뷰포트 기준, 위에서 80% 지점보다 아래에 있으면 컨텐츠 보임
                    futureText.style.opacity = 1
                    futureText.style.transform = 'translateY(0%)'
                } else if (rect.top < thresholdTop) {
                    // 뷰포트 기준, 위에서 30% 지점보다 올라가면 완전히 숨기기
                    futureText.style.opacity = 0
                    futureText.style.transform = 'translateY(5%)'
                }
            } else {
                // 모바일이 아닌 경우 항상 보이게 설정
                futureText.removeAttribute('style')
            }
        }

        function init() {
            handleScroll()

            // 스크롤 이벤트 리스너 등록
            window.addEventListener('scroll', handleScroll)
            window.addEventListener('resize', handleScroll)
        }

        init()
    }


    // 헤더 높이 측정 함수
    const getElementHeight = (element) => {
        return element ? element.offsetHeight : 100 // 기본값 100px
    }

    function setHeaderStyle() {
        const header = document.querySelector('.header')
        const futureCaseContainer = document.querySelector('.the-future-case')

        const headerHeight = getElementHeight(header)
        let isHeaderHidden = false
        let lastScrollY = window.scrollY

        // 스타일 설정 함수
        const setStyles = () => {
            // header 스타일 적용 객체
            const headerStyles = {
                position: 'fixed',
                top: '0',
                left: '0',
                transform: 'translateY(0)'
            }

            // 헤더와 컨테이너에 스타일 적용 (초기값)
            if (header && futureCaseContainer) {
                // 헤더에 스타일 적용
                // header.classList.add('is-fixed')
                Object.assign(header.style, headerStyles)

                // 컨테이너에 패딩 적용
                futureCaseContainer.style.paddingTop = `${headerHeight}px`
            }
        }

        // 스크롤에 따른 UI 업데이트 함수
        const updateUI = () => {
            const scrollPosition = window.scrollY
            const isScrollingDown = scrollPosition > lastScrollY
            const isBeyondHeader = scrollPosition >= headerHeight

            if (isBeyondHeader) {
                if (isScrollingDown && !isHeaderHidden) {
                    header.style.transform = 'translateY(-6.25rem)'
                    isHeaderHidden = true
                } else if (!isScrollingDown && isHeaderHidden) {
                    header.style.transform = 'translateY(0)'
                    isHeaderHidden = false
                }
            } else {
                if (isHeaderHidden) {
                    header.style.transform = 'translateY(0)'
                    isHeaderHidden = false
                }
            }
            lastScrollY = scrollPosition
        };

        // 초기화 함수
        const init = () => {
            setStyles() // 초기 스타일 설정
            updateUI() // 초기 UI 상태 업데이트

            // 스크롤 이벤트 리스너 등록
            window.addEventListener('scroll', updateUI)
            // 리사이즈 이벤트 리스너 등록 (화면 크기 변경 시 재계산)
            window.addEventListener('resize', () => {
                // 스타일 재설정 및 UI 업데이트
                setStyles()
                updateUI()
            })
        }
        init()
    }


    /*실행*/
    window.addEventListener('load', () => {
        setHeaderStyle()
        glideText()
        parallaxEffect()
    })
</script>