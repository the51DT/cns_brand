<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title><%= data.title %></title>
  <meta name="description" content="<%= data.description %>">
  <link rel="stylesheet" href="/src/assets/css/index.css" />
  <link rel="shortcut icon" href="/src/assets/image/favicon.ico">
</head>
<body class="dark-mode">
    <div class="wrap has-hero the-future-case">
        <%- include('src/_inc/header.html') %>
        <!-- //헤더 영역 -->
        <div class="sub-content__wrap">
            <div class="full-type-content__wrap">
                <div class="future-inner__wrap">
                    <div class="future-text">
                        <div class="main-title font-head-xl font-semibold color-text-on-bg">AX(AI ransformation)</div>
                        <div class="sub-title font-head-md color-text-on-bg">전략으로 실현하는 미래 경쟁력</div>
                        <div class="description-text font-body-md mb-spacing05 color-text-on-bg">
                            지금까지 수많은 기술 혁신이 기업 업무 환경을 변화시켜 왔으나, 현재의 인공지능(Artificial Intelligence, AI)만큼 변화를 이끈 혁신은 없었습니다. 기업 환경에서 AI는 단순한 기술 도입을 넘어
                            비즈니스의 근본적인 변화를 이끄는 핵심 동력으로 자리 잡고 있습니다.
                            <br><br class="display-pc">
                            LG CNS는 고객의 성공적 AX 구현을 위해 전 여정에서 고객과 함께 실질적인 성과를 만들어 가는 AX Enabler입니다. AX 전략 수립부터 솔루션 구축, 운영 최적화까지 필요한 모든 서비스를 제공하며,
                            에이전틱 AI를 통해 비즈니스 혁신을 지원하는 파트너입니다. 다양한 산업 고객의 디지털 전환을 선도하며 축적한 도메인 전문성과 레거시 시스템에 대한 이해를 바탕으로 고객 비즈니스 환경에 특화된 해법을 도축하며 AX
                            여정을 함께 합니다.
                        </div>
                        <div class="button__wrap align-left">
                            <a href="#" target="_self" class="btn btn-x-large btn-secondary">
                                <span class="btn__text color-text-on-bg">AX  컨설팅 상세보기</span>
                                <i class="ico icon-main-navigation-right-wh40 btn__icon"></i>
                            </a>
                        </div>
                    </div>
                    <!-- //title -->
                    <div class="future-content">
                        <%
                            const itemListData = [
                                {
                                    content : [
                                        {
                                            title : 'Agentic AI: <br>자율적 문제 해결의 시대',
                                            text : "에이전틱 AI(Agentic AI)는 단순히 질문에 답변하거나 보고서를 생성하는 것을 넘어, 목표 달성을 위해 자율적으로 계획, 실행과 평가를 반복하며 스스로 판단하고 복잡한 문제를 해결하는 진화된 AI 형태입니다. 2024년 11월, 가트너는 IT 심포지엄/엑스포 2024에서 2025년 기업이 주목해야 할 10대 전략 기술 트렌드 중 하나로 '에이전틱 AI'를 선정했으며, 딜로이트 보고서는 2025년까지 생성형 AI를 사용하는 기업의 25%가 에이전틱 AI 파일럿 프로그램을 시작할 것으로 예측합니다. <br>운영 효율성을 높이고, 반복적인 작업을 자동화하며, 직원이 보다 가치 있는 이니셔티브에 집중할 수 있게 하는 에이전틱 AI가 기업 업무에 미칠 파급력은 강력합니다. 에이전틱 AI가 기업 업무에 적용되면 단순한 기술의 변화가 아닌, 일하는 방식의 패러다임이 근본적으로 변화하게 됩니다."
                                        },
                                    ]
                                },
                                {
                                    content : [
                                        {
                                            title : 'AX 전문가 주도의 기업 혁신',
                                            text : 'AX는 디지털 전환(Digital Transformation, DX)을 넘어 AI 중심으로 기업의 변화를 추구하는 개념입니다. 기업은 에이전틱 AI를 통해 경쟁력을 강화하고, AX를 바탕으로 새로운 가치를 창출하는 여정을 본격적으로 시작하고 있습니다. <br>퓨어스토리지가 국내 기업을 대상으로 실시한 조사에 따르면, 기업의 69.3%가 이미 AX를 계획하거나 추진 중이며, 이는 AI가 기업 경쟁력의 핵심 요소로 자리 잡고 있음을 보여줍니다. 그러나 성공적인 AX 여정에는 중대한 도전이 따릅니다. 기업의 71.4%는 AI 전문 인력 부족을, 68.1%는 초기 투입비용 과다를 AX 추진의 주요 장애물로 꼽았습니다. 더욱이, 기업의 65%는 생성형 AI 변환을 이끌 전문 지식의 부족을 인지하고 있습니다. <br>AX 구현은 단순한 기술 적용을 넘어, 업무 방식을 재설계하며, 기업의 사업 방식, 의사결정 구조 및 조직 운영 체계의 변화를 포함합니다. 전 기업 밸류 체인 전과정에 영향을 미치는 상황에서 신뢰할 수 있는 AX 전문 파트너의 필요성이 더욱 부각되고 있습니다.'
                                        },
                                    ]
                                },
                                {
                                    imageUrl: '/src/assets/image/sub/future_img_ai.png',
                                    content : [
                                        {
                                            title : 'future_img_ai',
                                            text : '최근 기업에서는 생성형 AI 기술을 활용해 생산성과 혁신을 극대화하고 있다. 초거대 언어 모델(LLM) 기반 기술은 고객 서비스에서 챗봇 및 자동화된 응답 시스템으로 활용되며, 맞춤형 마케팅 콘텐츠 생성에도 사용된다. 또한, 이미지 및 비디오 생성 AI는 디자인 및 광고 제작을 혁신하고, 코드 생성 AI는 소프트웨어 개발의 효율성을 높인다. 이 외에도 데이터 분석 자동화와 협업 도구 통합으로 업무 전반의 디지털 전환을 가속화하고 있다. 기업들은 이러한 기술을 통해 비용 절감과 고객 경험 개선을 동시에 이루고자 한다.'
                                        },
                                    ]
                                },
                            ]
                        %>
                        <%- include('src/component/cmp_item_list.html', Object.assign({}, locals, { 
                            jsonData: itemListData,
                            itemCount: 5, 
                        })) %>  
                    </div>
                    <!-- //content -->
                </div>
            </div>
        </div>
        <%- include('src/_inc/footer.html') %>
    </div>
</body>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        const futureText = document.querySelector('.future-text');
        const futureContent = document.querySelector('.future-content');

        if (!futureText || !futureContent) {
            console.error('Scroll effect elements not found.');
            return;
        }

        const isMobile = () => window.matchMedia('only screen and (max-width: 1023px)').matches;

        // Create a div to act as a scrollable space for text simulation
        const scrollPadder = document.createElement('div');
        scrollPadder.id = 'future-scroll-padder';
        futureContent.parentNode.insertBefore(scrollPadder, futureContent);

        // --- Main scroll handler for the new effect ---
        const handleNewScroll = () => {
            const scrollY = window.scrollY;
            const textScrollableHeight = futureText.scrollHeight - futureText.clientHeight;

            // Phase 1: Text scroll simulation
            if (textScrollableHeight > 0 && scrollY <= textScrollableHeight) {
                futureText.scrollTop = scrollY;
            } else if (textScrollableHeight > 0) {
                futureText.scrollTop = textScrollableHeight;
            }

            // Always run the parallax logic
            runParallaxEffect();
        };

        // --- Original parallax logic, slightly adapted ---
        const runParallaxEffect = () => {
            if (!isMobile()) {
                futureText.removeAttribute('style');
                return;
            }
            const rect = futureContent.getBoundingClientRect();
            const windowHeight = window.innerHeight;
            const thresholdTop = windowHeight * 0.3;
            const thresholdBottom = windowHeight * 0.8;

            if (rect.top <= thresholdBottom && rect.top >= thresholdTop) {
                const ratio = (rect.top - thresholdTop) / (thresholdBottom - thresholdTop);
                futureText.style.opacity = ratio.toFixed(5);
                const translateY = 5 * (1 - ratio);
                futureText.style.transform = `translateY(${translateY}%)`;
            } else if (rect.top > thresholdBottom) {
                futureText.style.opacity = 1;
                futureText.style.transform = 'translateY(0%)';
            } else if (rect.top < thresholdTop) {
                futureText.style.opacity = 0;
                futureText.style.transform = 'translateY(5%)';
            }
        };

        // --- Setup function that decides which logic to apply ---
        const setupView = () => {
            // Always remove existing listener to avoid duplicates
            window.removeEventListener('scroll', handleNewScroll);

            if (isMobile()) {
                // Use timeout to wait for render and get correct scrollHeight
                setTimeout(() => {
                    const textScrollableHeight = futureText.scrollHeight - futureText.clientHeight + 120;
                    
                    if (textScrollableHeight > 0) {
                        // If text is scrollable, create padding and use the new scroll handler
                        scrollPadder.style.height = `${textScrollableHeight}px`;
                        window.addEventListener('scroll', handleNewScroll);
                        handleNewScroll(); // Run once on setup
                    } else {
                        // If not scrollable, just use the original parallax
                        scrollPadder.style.height = '0px';
                        window.addEventListener('scroll', runParallaxEffect);
                        runParallaxEffect(); // Run once on setup
                    }
                }, 150);
            } else {
                // On desktop, reset everything
                scrollPadder.style.height = '0px';
                futureText.removeAttribute('style');
                futureText.scrollTop = 0;
            }
        };

        // --- Initial execution and resize handling ---
        setupView();
        window.addEventListener('resize', setupView);
    });
</script>